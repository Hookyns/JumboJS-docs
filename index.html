<!DOCTYPE html>
<html lang="cs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="icon" href="./images/jumbo.ico">

	<script src="scripts/jquery-3.1.1.min.js"></script>
	<script src="scripts/highlight.pack.js"></script>
	<script src="scripts/highlightjs-line-numbers.min.js"></script>
	<script src="scripts/default.js"></script>

	<link rel="stylesheet" href="styles/vs2015.css">
	<!--<link rel="stylesheet" href="styles/agate.css">-->
	<link rel="stylesheet" href="default.css">

	<title>JumboJS Documentation</title>
</head>
<body>
	<header>
		<img src="images/jumbo.png">
		<h1>JumboJS</h1>

		<div class="aside-nav">
			<ul>
				<li><a href="#">Home</a></li>
				<li><a href="#">Examples</a></li>
				<li><a href="#">Tutorials</a></li>
				<li><a href="https://github.com/Hookyns/JumboJS" target="_blank">GIT</a></li>
				<li><a href="https://gitter.im/JumboJS" target="_blank">GITTER</a></li>
			</ul>
		</div>
	</header>

	<div class="side-nav">
		<div class="mobile-menu-button" onclick="toggleMenu();"></div>
		<nav>
			<aside class="mobile-aside-nav">
				<ul>
					<li><a href="#">Home</a></li>
					<li><a href="#">Examples</a></li>
					<li><a href="#">Tutorials</a></li>
					<li><a href="https://github.com/Hookyns/JumboJS" target="_blank">GIT</a></li>
					<li><a href="https://gitter.im/JumboJS" target="_blank">GITTER</a></li>
				</ul>
			</aside>

			<ul id="doc-nav">
				<li>
					<a href="#fold-introduction">Introduction</a>

					<ul>
						<li><a href="#fold-about-jumbo">About JumboJS</a></li>
						<!--<li><a href="#fold-MVC">MVC pattern</a></li>-->
						<!--<li><a href="#fold-IoC">IoC principle</a></li>-->
						<!--<li><a href="#fold-ORM">ORM technique</a></li>-->
					</ul>
				</li>
				<li>
					<a href="#fold-getting-started">Getting Started</a>

					<ul>
						<li><a href="#fold-node-and-npm">Node.js and Npm</a></li>
						<li><a href="#fold-installation">Installation</a></li>
						<li><a href="#fold-project-structure">Project structure</a></li>
						<li><a href="#fold-namespaces">Namespaces</a></li>
						<li><a href="#fold-configuration">Configuration</a></li>
						<li><a href="#fold-routing">Routing</a></li>
						<li><a href="#fold-controllers">Controllers</a></li>
						<li><a href="#fold-dependency-injection">Dependency Injection</a></li>
						<li><a href="#fold-cli">CLI</a></li>
					</ul>
				</li>
				<li>
					<a href="#fold-api">API</a>

					<ul>
						<li><a href="#fold-adapters">Adaters</a></li>
						<li><a href="#fold-api-application">Application</a></li>
						<li><a href="#fold-base">Base</a></li>
						<li><a href="#fold-api-ioc">Ioc</a></li>
						<li><a href="#fold-logging">Logging</a></li>
						<li><a href="#fold-utils">Utils</a></li>
						<!--<li><a href="#fold-validation">Validation</a></li>-->
					</ul>
				</li>
				<li>
					<a href="#fold-packages">Packages</a>

					<ul>
						<li><a href="#fold-jumplate">Jumplate</a></li>
						<!--<li><a href="#fold-jumbo-entity">Jumbo Entity</a></li>-->
					</ul>
				</li>
			</ul>
		</nav>
	</div>

	<main>
		<section>
			<h1 id="fold-introduction">Introduction</h1>

			<section>
				<h2 id="fold-about-jumbo">About JumboJS</h2>
				<p>
					JumboJS is fast modern enterprise level MVC framework for Node.js which focuses on object-oriented
					programming, Inversion of Control and Separation of Concerns.
				</p>

				<h3>Main Features of JumboJS</h3>
				<ul>
					<li>No require hell! Global lazy-loading namespace exists,</li>
					<li>native async & await support,</li>
					<li>integrated Node.js clustering - multi core/CPU support,</li>
					<li>advanced dynamic routing system (just one route enough for most apps),</li>
					<li>Inversion of Control - constructor Dependency Injection,</li>
					<li>code can be changed while runtime,</li>
					<li>unexpected errors are catched and logged, then process is restarted,</li>
					<li>client-side micro framework automatically creating SPA without any client-side programming,</li>
					<li>fully configurable logging with log levels,</li>
					<li>subdomains! More "modules" in one application accessible via subdomains,</li>
					<!--<li>a lot of things integrated but changeable thanks to Adapters,</li>-->
					<li>code-first ORM/ODM with migrations (UniMapperJS),</li>
					<li>automatic sessions,</li>
					<li>memory and disk cache,</li>
					<li>integrated email sender (soon),</li>
					<li>high performance - 3 900 requests per second with one worker (2,33 GHz core),</li>
					<li>low dependecy,</li>
					<li>integrated globalization,</li>
					<li>and more...</li>
				</ul>

				<h3>Framework structure</h3>
				<p>
					In the picture below you can see basic framework structure and data flow. Some things are abstracted
					and
					joined to keep diagram clear.
				</p>
				<div class="center-content">
					<a href="./images/Jumbo-structure-and-data-flow-hr.png"><img
							src="./images/Jumbo-structure-and-data-flow-hr.png" width="90%" style="max-width: 1200px;"></a>
				</div>
			</section>

			<!--<section>-->
			<!--<h2 id="fold-MVC">MVC</h2>-->
			<!--<p>-->
			<!--MVC is one of the architectural pattern which split application into three logical layers which ...-->
			<!--</p>-->
			<!--<p style="color: #888">-->
			<!--Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur non varius neque,-->
			<!--in sollicitudin mauris. Etiam vehicula libero finibus luctus iaculis.-->
			<!--Suspendisse interdum leo lacus, ac pharetra nisl iaculis vel. Mauris varius pretium augue,-->
			<!--efficitur sagittis lacus blandit non. Nunc vel sodales felis, quis efficitur nibh.-->
			<!--In tempus, sem a molestie interdum, sapien odio aliquam enim, sit amet ornare-->
			<!--metus lectus eget augue. Fusce metus nisi, interdum quis velit id, semper pharetra leo.-->
			<!--Nulla sed accumsan lorem. Proin eleifend dictum massa, ac vulputate ex dapibus et.-->
			<!--</p>-->
			<!--</section>-->

			<!--<section>-->
			<!--<h2 id="fold-IoC">IoC</h2>-->
			<!--<p>-->
			<!--IoC stands for Inversion of Control. It is type of approach which tells ...-->
			<!--</p>-->
			<!--<p style="color: #888">-->
			<!--Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur non varius neque,-->
			<!--in sollicitudin mauris. Etiam vehicula libero finibus luctus iaculis.-->
			<!--Suspendisse interdum leo lacus, ac pharetra nisl iaculis vel. Mauris varius pretium augue,-->
			<!--efficitur sagittis lacus blandit non. Nunc vel sodales felis, quis efficitur nibh.-->
			<!--In tempus, sem a molestie interdum, sapien odio aliquam enim, sit amet ornare-->
			<!--metus lectus eget augue. Fusce metus nisi, interdum quis velit id, semper pharetra leo.-->
			<!--Nulla sed accumsan lorem. Proin eleifend dictum massa, ac vulputate ex dapibus et.-->
			<!--</p>-->
			<!--</section>-->

			<!--<section>-->
			<!--<h2 id="fold-ORM">ORM</h2>-->
			<!--<p>-->
			<!--ORM stands for Object Relational Mapping. ORM is some layer which cover basic relational database-->
			<!--with objectve wraps over it........-->
			<!--</p>-->
			<!--<p style="color: #888">-->
			<!--Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur non varius neque,-->
			<!--in sollicitudin mauris. Etiam vehicula libero finibus luctus iaculis.-->
			<!--Suspendisse interdum leo lacus, ac pharetra nisl iaculis vel. Mauris varius pretium augue,-->
			<!--efficitur sagittis lacus blandit non. Nunc vel sodales felis, quis efficitur nibh.-->
			<!--In tempus, sem a molestie interdum, sapien odio aliquam enim, sit amet ornare-->
			<!--metus lectus eget augue. Fusce metus nisi, interdum quis velit id, semper pharetra leo.-->
			<!--Nulla sed accumsan lorem. Proin eleifend dictum massa, ac vulputate ex dapibus et.-->
			<!--</p>-->
			<!--</section>-->
		</section>

		<section>
			<h1 id="fold-getting-started">Getting Started</h1>

			<section>
				<h2 id="fold-node-and-npm">Node.js and Npm</h2>

				<p>
					<strong>JumboJS</strong> is built upon <strong>Node.js</strong> so you need
					<a target="_blank" href="http://nodejs.org">Node.js</a> in version
					<a target="_blank" href="http://nodejs.org/en/download/current/">8.10.x</a> or higher and its
					package
					manager <strong>npm</strong>.
				</p>

				<!--<h3>What is Node.js?</h3>-->
				<blockquote>
					Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
					Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
					Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
					(taken from <a target="_blank" href="http://nodejs.org">nodejs.org</a>)
				</blockquote>
			</section>

			<section>
				<h2 id="fold-installation">Installation</h2>
				<p>
					The best way how to start with <strong>JumboJS</strong> is to install <strong>jumbo-developer</strong>
					package and use it to create new project.

					So first install <strong>jumbo-developer</strong> via <strong>npm</strong>
					<span class="inline-code">npm install jumbo-developer -g</span>.
				</p>
				<p>
					Now you can create your first project. Enable <strong>jumbo-developer</strong>, type
					<span class="inline-code">jumbo-developer</span> to console/terminal and developer tool will start.

					First you must specify your project location, it'll do nothing, it just save your location and all
					future actions will be processed over that location.

					Then you should finally create your project. Type <span class="inline-code">create project</span>,
					and
					your first project is going to be created in directory you specified in previous step.
				</p>
				<p>
					Now you should run your application. Go to your project directory and run it via
					<span class="inline-code">npm start</span>. Your application should run on address
					<em>http://127.0.0.1</em> on port 30000. If you want to change default port, edit app.js file,
					and change parameter of runWhenReady(port, ...).
				</p>
				<blockquote>
					If you want to use framework's subdomains, you should edit your local hosts file and add
					some domain for your application.
				</blockquote>
			</section>

			<section>
				<h2 id="fold-project-structure">Project Structure</h2>
				<pre>
    - adapters <span class="hljs-comment"># Adapters for components</span>
    - app <span class="hljs-comment"># Your main folder</span>
        - controllers <span class="hljs-comment"># Place controllers here</span>
        - facades <span class="hljs-comment"># Place facades here</span>
        - models <span class="hljs-comment"># Place models here</span>
        - services <span class="hljs-comment"># Place services here</span>
        - sub-apps <span class="hljs-comment"># Folder for subapps which will be accessible via subdomains</span>
            - Example <span class="hljs-comment"># Subdomain name</span>
                - controllers
                - models
                - ...
        - templates <span class="hljs-comment"># Place view templates here</span>
					<!-- - validators <span class="hljs-comment"># Validators for models</span>-->
    - bootstrap <span class="hljs-comment"># Folder for init scripts (registering routes, dependency, etc.)</span>
    - data
        - errors <span class="hljs-comment"># Error HTML pages</span>
        - logs <span class="hljs-comment"># Logs are saved here</span>
        - uploads <span class="hljs-comment"># All uploaded files are placed here</span>
    - public <span class="hljs-comment"># Everything inside is accessible at /public/</span>
        - images
        - scripts
        - styles
    - temp
        - cache <span class="hljs-comment"># Cached templates</span>
        - session <span class="hljs-comment"># Stored session data</span>
    - app.js <span class="hljs-comment"># Main script</span>
    - config.js <span class="hljs-comment"># App configuration</span>
            </pre>
			</section>

			<section>
				<h2 id="fold-namespaces">Autoloaded Namespaces</h2>
				<p>
					In JumboJS there is no need to use requires/imports with complicated relative paths (require-hell).
					Yes, you must require Node.js modules or your custom 3rd party stuff but framework classes
					are autoloaded to global namespaces.
				</p>
				<p>
					There are global Objects <strong>Jumbo</strong> and <strong>App</strong>.
					These Objects contain all classes from framework which are autoloaded when you start app.
					These Objects create namespaces and structure of namespaces is copied from folder structure.
					Namespace <strong>Jumbo</strong> point to framework core.
					Namespace <strong>App</strong> points to folder /app/.
					Eg. <b>/app/controllers/HomeController.js</b> file is accessible via
					<b>App.Controllers.HomeController</b>.
				</p>
				<p>
					Classes in namespaces are defined as getters and are required just in time so global namespaces are
					lazy, same as calling require().
					Inside getters there is require() call so after first get it's cached thanks to require cache.
				</p>
			</section>

			<section>
				<h2 id="fold-configuration">Configuration</h2>
				<p>
					For basic configuration there is file /config.js. It's JS file so you can use IDE's completition.
					And you can add custom properties into config object too. This config is globally readonly
					accessible
					via <strong>Jumbo.config</strong>.
				</p>

				<section>
					<h3>Default Config File</h3>
					<article class="code">
						<h1>config.js</h1>
						<pre><code>const $cfg = require("jumbo-core/config-options").Configurations;
const $umjs = require("unimapperjs");
const MySqlAdapter = require("unimapperjs/adapters/MySqlAdapter");

/**
 * @name ApplicationConfig
 */
const applicationConfig = {
	/**
	 * Used for styles of Error reporting
	 * In development mode Errors will be shown in browser (browser errors not implemented yet) and in console
	 * In production mode Errors will be logged just to file if log enabled
	 */
	deployment: $cfg.Deployment.Development,

	/**
	 * For debuging; disable clustering and run app in one debugable process
	 */
	// debugMode: false,

	/**
	 * Protocol setting
	 * If you set HTTPS protocol specify privateKey and certificate paths
	 */
	protocol: {
		/**
		 * @default Http
		 */
		protocol: $cfg.Protocols.Http,

		/**
		 * Private key path
		 */
		privateKey: "data/private.key",

		/**
		 * Certificate path
		 */
		certificate: "data/certificate.crt",

		/**
		 * Or just PFX archive certificate
		 */
		pfx: "",

		/**
		 * Certifice passphrase
		 */
		passphrase: null
	},

	/**
	 * Multi-core support
	 */
	clustering: {
		/**
		 * 0 for automatic clustering driven by number of CPU's cores
		 * @default 0
		 */
		numberOfWorkers: 0
	},

	/**
	 * Enable template cache and define memory limit
	 */
	cache: {
		/**
		 * @default true
		 */
		enabled: true,

		/**
		 * Size limit for templates saved in memory
		 * JumboJS store often used templates in memory
		 * @default 10 MB
		 */
		memoryCacheSizeLimit: 10e6
	},

	/**
	 * Session configuration
	 */
	session: {
		/**
		 * Name of cookie which stores users's session ID
		 */
		sessionsCookieName: "JUMBOSESID",

		/**
		 * Length of session's life in days. It'll be deleted from disk after that time
		 * @type {Number} Number of days
		 * @default 30
		 */
		sessionLifetime: 30,

		/**
		 * Limit size of data saved in memory
		 * Not implemented yet
		 */
		memorySizeLimit: 20e6,

		/**
		 * Disable sessions saving to disk - speed boost
		 * When true, memorySizeLimit is ignored
		 * @default false
		 */
		justInMemory: false,
	},

	/**
	 * Enable log and set log level
	 */
	log: {
		/**
		 * @default true
		 */
		enabled: true,

		/**
		 * @default Warning
		 */
		level: $cfg.LogLevels.Warning
	},

	/**
	 * Maximal allowed number of requests per second. You can limit server stress.
	 * If more than specified request count will come, new requests in rest of one second obtain 429 code.
	 * Static files are counted into this number of requests
	 * @default null
	 * @type { Number || null }
	 */
	maxRequestPerSecond: null,

	/**
	 * Enable prevention of (D)DOS attacks
	 * It internally enable requests monitoring which will count number of requests per IP
	 * If IP makes more request per second new requests from that IP will be refused with code 403.
	 * Requests will be still accepted by server but framework will refuse to continue and save resources which
	 * proccessing of that request can framework take.
	 */
	DOSPrevention: {
		/**
		 * @default false
		 */
		enabled: false,

		/**
		 * The limit of request per second from same IP
		 * @description Warn! If you use framework static server and your index page have
		 * more than 100 links (scripts, styles, images etc.) client will be blocked!
		 * @default 100
		 */
		maxRequestPerIP: 100,

		/**
		 * Duration of IP blocking [in seconds]
		 * @default 3600
		 */
		blockTime: 3600
	},

	/**
	 * Allows you to use more languages (defined in URL right after first slash; eg. domain.tld/en-us/page/article/1)
	 */
	globalization: {
		/**
		 * Allow using languages
		 */
		enabled: true
	},

	/**
	 * Maximal size of POST data
	 * @default 5 MB
	 */
	maxPostDataSize: 5e6,

	/**
	 * Object with domains
	 */
	domains: {
		"default": $umjs.createDomain(MySqlAdapter, {
			host: "localhost",
			user: "test",
			password: "test",
			database: "node-task-manager"
		})
	}

	// You can define your own settings here,.. it'll be available via global Jumbo.config
};

module.exports = applicationConfig;</code></pre>
					</article>

					<p>
						You can remove all properties with default values, this config extends the framework one with
						default values.
					</p>
				</section>

				<section>
					<h3>Handlers</h3>
					<p>
						Handlers are proprties in framework's classes which allow you to change some behavior.
						It's next level of configuration.
					</p>

					<section>
						<h4>
							* : Jumbo.Application.Application.setBlockIpListener(listener: blockIpListener)
						</h4>
						<p><em>Instance method</em></p>
						<p>
							You can handle IP blocking when IP / request / sec limit reached. You can block this IP in
							firewall or you can do whatever you want.
						</p>

						<section class="method">
							<h5>
								<small>callback</small>
								blockIpListener(blockedIP)
							</h5>
							<b>Params</b>
							<ul>
								<li><b>blockedIP : String</b></li>
							</ul>
						</section>
					</section>

					<section>
						<h4>
							* : Jumbo.Application.setStaticFileResolver(handler: staticFileResolver)
						</h4>
						<p><em>instance method</em></p>
						<p>
							You can handle requests for static files on your own.
						</p>
						<section class="method">
							<h5>
								<small>handler</small>
								staticFileResolver(fileName: string, callback: staticFileResolverCallback)
							</h5>
							<h5>Params</h5>
							<ul>
								<li><b>fileName : String</b> <em>Full file path, resolved</em></li>
								<li><b>callback : staticFileResolverCallback</b> <em>Handler callback</em></li>
							</ul>
						</section>
						<section class="method">
							<h5>
								<small>callback</small>
								staticFileResolverCallback(error: Error, readStream: fs.ReadStream, mime: string, size:
								number, headers?: { [key: string]: any })
							</h5>
							<h5>Params</h5>
							<ul>
								<li><b>error : Error</b> <em>Error</em></li>
								<li><b>readStream : fs.ReadStream</b> <em>File read stream of given static file</em>
								</li>
								<li><b>mime : String</b> <em>Expiration in seconds</em></li>
								<li><b>size : Number</b> <em>size of given static file</em></li>
								<li><i>optional</i> <b>headers : { [key: string]: any }</b> <em>Optional response
									headers</em></li>
							</ul>
						</section>
						<!--<section class="method">-->
						<!--<h5><b></b>-->
						<!--<ul>-->
						<!--<li></li>-->
						<!--</ul>-->
						<!--</h5>-->
						<!--</section>-->
					</section>

					<section>
						<h4>
							* : Jumbo.Application.Application.setTemplateAdapter(adapter: <a
								href="#fold-adapters-template">ITemplateAdapter</a>)
						</h4>
						<p><em>Instance method</em></p>
						<p>
							Set template adapter for view rendering.
						</p>
					</section>

					<section>
						<h4>Jumbo.Loger.Log.logFunction
							<small> : logFunctionHandler</small>
						</h4>
						<p><em>Static field</em></p>
						<p>
							You can change the default logging and store log messages on your own.
						</p>

						<section class="method">
							<h5>
								<small>callback</small>
								logFunctionHandler(message, type)
							</h5>
							<b>Params</b>
							<ul>
								<li><b>message : String</b></li>
								<li><b>type : String</b></li>
							</ul>
						</section>
					</section>
				</section>

				<section>
					<h3>Default application script</h3>
					<article class="code">
						<h1>app.js</h1>
						<pre><code>/**
 * Application initial script
 */

// Get application from jumbo-core
let application = require("jumbo-core").application;

// Call route config for registering locations
require("./bootstrap/locator-config")(application.getLocator());

// Call DI registrar
require("./bootstrap/di-registrar")(application.getDIContainer());

// Register template adater - not needed if you want to use default adapter
// application.setTemplateAdapter(Jumbo.Adapters.TemplateAdapter);

// Register application for run at port 80; It'll run after framework do all async jobs
application.runWhenReady(80, function() {
	// You can do something after start
});</code></pre>
					</article>
				</section>

			</section>

			<!-- Routing -->
			<section>
				<h2 id="fold-routing">Routing</h2>
				<p>
					JumboJS has advanced routing system (called <strong>Locator</strong>) which allows you to define
					powerful dynamic routes (<strong>locations</strong>).
					In base project there is file <b>/bootstrap/locator-config.js</b> where locations are registered.
				</p>
				<p>
					See API: Application: <a href="#fold-api-application-locator">Locator</a> for more information.
				</p>

				<section>
					<h3>Locator config</h3>
					<article class="code">
						<h1>/bootstrap/locator-config.js</h1>
						<pre><code>/**
 * Locator configuration - setting host, sub-domains and locations
 * @param {Locator} locator
 */
module.exports = function(locator) {
	const types = locator.constructor.ParamType;

	/*
	 * DOMAINS
	 **************************************************************************************************/
	// Default sub-domain which will route to base app;
	// both urls with and without www will work
	locator.setMainSubdomain("www");

	// Create admin.yourdomain.tld which will route to /app/sub-apps/admin folder
	locator.addSubdomain("admin");


	/*
	 * LOCATIONS
	 **************************************************************************************************/
	// Allows you to change url delimiter from "/" to whatever you want
	// In this case "-" gonna be used, eg. /controllerexample-actionname-foo?bar=5&baz=0
	// But you still define locations with "/"
	locator.setDelimiter("-");

	// example; rewrite action name; limit id with RegExp
	locator.addLocation("locationName", "$controller/delete/$id", {
		"action": "deleteEntity", // no $action in location, so "deleteEntity" gonna be used
		"$id": /[0-9]+/,
		params: {
			parentId: 1 // this param is gonna be added to request with given value; as some default data
		}
	});

	// example2; specific URL pointing to HomeController.actionIndex
	// with optional parameter foo limited with RegExp
	locator.addLocation("locationName2", "Specific-url-what-ever-you-want[/$foo]", {
		"$foo": /[0-9]+/,
		"controller": "Home", // route to this controller
		"action": "index" // and this action
	});

	// Default route - let it last
	locator.addDefaultLocation("[$controller[/$action[/$id]]]");


	/*
	 * URL ALIASES
	 **************************************************************************************************/
	locator.addUrlAlias("/public/favicon.ico", "/favicon.ico"); // URL '/public/favicon.ico' has alias '/favicon.ico'
};</code></pre>
					</article>
				</section>

				<section>
					<h3>Locations</h3>

					<p>Just few points you should know about <strong>locations</strong> (routes).</p>

					<ul>
						<li>
							There are variables <strong>$controller</strong>, <strong>$action</strong> and
							<strong>$globlanguage</strong> which stands for any controller, any action and locale.
						</li>
						<li>
							<strong>$globlanguage</strong> stands for locale in URL, if you not place it in location
							string
							it's gonna be placed at the begining by locator as "$globlanguage/" + location string.
						</li>
						<li>define your own parameter (slash param) with name starting with <b>$</b>,</li>
						<li>use <b>/</b> (slash) as separator of location's parts (eg. $controller/$action),</li>
						<li>
							you can use RegExp to restrict your parameter's value - to <strong>option object</strong>
							add property with key
							equals to your param's name, including <b>$</b>, as value set your RegExp,
						</li>
						<li>
							you can set param's default value - to <strong>option object</strong> add object property
							<strong>params</strong> and add properties (param names) with required default value
						</li>
						<li>use square brackets to mark something optional.</li>
					</ul>

					<blockquote>
						If need group inside param regex, use not-matching group<b>(?:something)</b>.
					</blockquote>
				</section>
			</section>

			<!-- Controllers -->
			<section>
				<h2 id="fold-controllers">Controllers</h2>
				<p>
					Controllers are some kind of entry points to your application. Controller's methods,
					which should be accessible from web, are called <strong>actions</strong> and must begin with keyword
					"action", "get", "post", "put" or "delete".
					This words tell framework you want let clients access this method from browser.
					Keyword "action" means all requests with all methods. The other words then stands for HTTP methods.
				</p>

				<p>
					Controllers must be placed in <span class="inline-code">/app/controllers/</span>.
					Name convention is PascalCase and name must ends with keyword "Controller".
					Controller should be exported ES6 class and all actions must be <strong>async</strong>.
				</p>

				<blockquote>
					Default controller name is <strong>HomeController</strong> and default action name is
					<strong>actionIndex</strong>. Default action or controller name means that those names aren't used
					in
					URL.
					So yourweb.tld/ points to HomeController::actionIndex(). If you use long format URL with default
					names
					you'll be redirected to short format URL. It prevents duplicate content from occurring.
				</blockquote>

				<blockquote>
					If some method in framework requires controller or action name, it's its name but without keyword.
					Eg. ExampleController's name is <strong>Example</strong>; actionLogout's name is
					<strong>logout</strong>.
				</blockquote>

				<h3>Actions</h3>
				<p>
					What actions are is written in paragraphs above. Name convention is lowerCamelCase and name must
					starts with keyword "action" or lowercased method name. Actions must be async (ES7).
				</p>

				<!--<blockquote>-->
				<!--In the future action's prefixes "getAction", "postAction", "deleteAction", etc. will be implemented,-->
				<!--this prefixes will limit http method. It means that eg. getActionExample() (/controller/example/)-->
				<!--will be accessible only with GET method.-->
				<!--</blockquote>-->

				<h3>Action Parameters</h3>
				<p>
					All parameters (query params and <strong>location</strong>'s params under defined names) from
					requested
					URL are injected to actions as parameters under their names in order you define them in action.
					Eg. if you request for <span class="inline-code">/articles/delete/5?foo=bar</span>, two params
					exist.
					First parameter is <b>5</b> which is defined in default <strong>location</strong> as <b>id</b>
					and second parameter is <b>bar</b> as <b>foo</b>. These two params will be injected to your action
					<span class="inline-code">actionDelete(id, foo) {}</span> to match names you defined. In that action
					you wait for <b>id</b> and <b>foo</b>. If these parameters exist in request, action will be called
					with that parameters in right order, matched by parameters names.
				</p>

				<h3>Returning methods</h3>
				<p>
					Returning methods are methods implemented in class <strong>Jumbo.Base.Controller</strong> and
					these methods end requests and return data or errors. See API: Base:
					<a href="#fold-base-controller">Controller</a>.
				</p>

				<section>
					<h3>Example Controller</h3>
					<article class="code">
						<h1>Example of controller</h1>
						<pre><code>/**
 * // TODO: Describe your controller
 * @class ExampleController
 * @memberOf App.Controllers
 */
class ExampleController extends App.Controllers.BaseController {
	/**
	 * Default view action
	 */
	async actionIndex() {
		return "Hello world!";
	}

	async getSomeObject() {
		return { // JSON response
			foo: "bar"
		};
	}

	async getView() {
		return this.view({ optional: "data object" });
	}
}

module.exports = ExampleController;</code></pre>
					</article>
				</section>

				<section>
					<h3>Sequence diagram</h3>
					<p>
						There is some sequence diagram which show you how are actions called in controllers.
					</p>
					<div class="center-content">
						<a href="./images/Jumbo-controller-sequence.png">
							<img src="./images/Jumbo-controller-sequence.png" width="90%" style="max-width: 1200px;">
						</a>
					</div>
					<p>
						When request from client comes to server, Application handle that, verify request target and do
						some
						other stuff.
						Then if everything is ok, Application let ControllerFactory create ExampleController instance
						for
						given request.
					</p>
					<p>
						When instance of ExampleController is created, internal _initController() method is called and
						request, response, session and diScope parameters are set to controller. Request and response
						are
						not accessible in controller's constructor.
					</p>
					<p>
						Now it's time for calling action. But first there is beforeActions() method which you can use
						to verify user or initialize something or whatever else.
						This method can hadle the request and return result if you want, then action is not gonna be
						called.
						If you not return enything, the corresponding action's gonna be called. This method must be
						async too.
					</p>
				</section>

				<section>
					<h3>Sessions</h3>
					<p>
						Session is object in controller instance (property <strong>session</strong>) which is stored in
						memory, that allows you to store instances and sure it's much faster. But it's saved on disk
						too,
						because server can crash for some reason and maybe you store big data and have low memory on
						your
						server so disk provides you big storage for your sessions.
					</p>
				</section>
			</section>

			<!-- DI -->
			<section>
				<h2 id="fold-dependency-injection">Dependency Injection</h2>
				<p>
					In <strong>JumboJS</strong> there is implemented <strong>constructor injection</strong> which allows
					you
					to obtain instances of your services in constructors and other classes.
					For example you have UserAuthService service
					which do some user auth stuff. You want instance of this service in controller so you must create
					its instance but UserAuthService need eg. 3 next services or some other class's instances.
					Without DI you must create all on your own. With DI, you just register your services and that's all.
					You write service name as parameter of constructor and framework resolve its instance for you.
				</p>

				<blockquote>
					Example codes are just examples.
				</blockquote>

				<section>
					<h3>Example without DI</h3>

					<p>In this example, you must create instance of each class on your own. If you have 10 controllers,
						with same or similar dependencies, you must write more than two hundred lines of code.</p>

					<article class="code">
						<h1>ExampleController.js</h1>
						<pre><code>class ExampleController {
	constructor() {
		this.userAuthService = new App.Services.UserAuthService(
			new UserRepository(
				new Jumbo.Orm.EntityManager(
					new Jumbo.Orm.DBContext(Jumbo.Config.Database.default)
				)
			),
			new UserAccountRepository(
				new Jumbo.Orm.EntityManager(
					new Jumbo.Orm.DBContext(Jumbo.Config.Database.default)
				)
			),
			new SomeThirdNeededService(
				new SomeClass()
			)
		);

		this.someOtherService = new SomeOtherService(
			new EnterpriseRepository(
				new Jumbo.Orm.EntityManager(
					new Jumbo.Orm.DBContext(Jumbo.Config.Database.default)
				)
			),
			new CompanyRepository(
				new Jumbo.Orm.EntityManager(
					new Jumbo.Orm.DBContext(Jumbo.Config.Database.default)
				)
			),
			new SomeThirdNeededService(
				new SomeClass()
			)
		);
	}

	async beforeActions() {
		var user = await this.userAuthService.findUser(this.session.userId);

		if (user == null) {
			this.returnError(null, 403);
			return;
		}

		// Do something with user
	}
}</code></pre>
					</article>

					<section>
						<h3>Example with DI</h3>

						<p>
							In this example, you have very simple controller and every other controller will look like
							this.
							You just register your classes (as services) and dependencies are resolved with framework
							automatically and
							injected to constructor.
						</p>

						<article class="code">
							<h1>ExampleController.js</h1>
							<pre><code>class ExampleController {
	constructor(UserAuthService, SomeOtherService) {
		this.userAuthService = UserAuthService;
		this.someOtherService = SomeOtherService;
	}

	async beforeActions() {
		var user = await this.userAuthService.findUser(this.session.userId);

		if (user == null) {
			return this.error("This string is logged message", 403);
		}

		// Do something with user
	}
}</code></pre>
						</article>

						<article class="code">
							<h1>di-registrar.js</h1>
							<pre><code>/**
 * Dependency registrar - registration of servics
 * @param {Jumbo.Ioc.DIContainer} container
 */
module.exports = function(container) {
	const LifetimeScope = Jumbo.Ioc.DIContainer.LifetimeScope;

	container.register(() => Jumbo.Config.Database.default, "DBConn",
		LifetimeScope.SingleInstance);

	container.register(Jumbo.Orm.DBContext,
		"DBContext", LifetimeScope.SingleInstance);

	container.register(Jumbo.Orm.EntityManager,
		"EntityManager", LifetimeScope.SingleInstance);

	container.register(App.Services.EnterpriseRepository,
		"EnterpriseRepository", LifetimeScope.ScopeInstance);

	container.register(App.Services.CompanyRepository,
		"CompanyRepository", LifetimeScope.ScopeInstance);

	container.register(App.Services.UserAccountRepository,
		"UserAccountRepository", LifetimeScope.ScopeInstance);

	container.register(App.Services.UserAuthService,
		"UserAuthService", LifetimeScope.ScopeInstance);

	container.register(App.Services.SomeThirdNeededService,
		"SomeThirdNeededService", LifetimeScope.ScopeInstance);

	container.register(App.Services.SomeOtherService,
		"SomeOtherService", LifetimeScope.ScopeInstance);
};</code></pre>
						</article>
					</section>

					<blockquote>
						If you want to resolve class manually somewhere in code, you can use
						<span class="inline-code">Jumbo.Ioc.DIContainer.instance.resolve("UserService")</span>
						or <span class="inline-code">this.scope.resolve("UserService")</span> if you
						are in controller and you want to resolve your class in controller's Scope.
						<span class="no-wrap">See API: <a href="#fold-api-ioc">Ioc</a>.</span>
					</blockquote>

				</section>
			</section>

			<!-- CLI -->
			<section>
				<h2 id="fold-cli">CLI</h2>
				<p>
					<strong>JumboJS</strong> has special package <strong>jumbo-developer</strong> which was created to
					support
					developing. It's console app which helps you with creating projects, controllers and their actions,
					services and more.
				</p>
				<p>
					You can download <strong>jumbo-developer</strong> via npm
					<span class="inline-code">npm install jumbo-developer -g</span>.
					It'll be installed as system command so then just type in console
					<span class="inline-code">jumbo-developer</span>.
					With cmd <span class="inline-code">help</span> you will see list of available commands
				</p>
			</section>
		</section>

		<section>
			<h1 id="fold-api">API</h1>

			<section>
				<h2 id="fold-adapters">Jumbo.Adapters</h2>
				<p>
					<strong>JumboJS</strong> is quite modular framework, it integrates many features but almost everything
					can be changed thanks <strong>adapters</strong>. Adapters are some classes which makes interfaces
					over some features.
				</p>
				<p>
					For example template adapter. It's class which must implements 3 methods (render, preCompile and
					renderPreCompiled).
					You should use whatever template engine you want but you must create adapter for that engine,
					it means that you must implement those 3 methods which returns what framework wants.
					Then you just register your adapter in configuration and it's done.
				</p>

				<!--<blockquote>-->
				<!--Adapters are not ready yet!-->
				<!--</blockquote>-->

				<h3 id="fold-adapters-template">Template Adapter</h3>
				<article class="code">
					<h1>Template adapter demo</h1>
					<pre><code>/**
 * Integrated template adapter for Jumplate
 */
var TemplateAdapter = {

	render: async function render(templatePath, layoutPath, dynamicLayout, data, context) {
		return "Basic function. Compile and render view and return complete result.";
	},

	preCompile: async function preCompile(templatePath, layoutPath, dynamicLayout) {
		return "If template engine contains precompilation which can be cached on disk and reused later, return precompiled code.";
	},

	renderPreCompiled: async function renderPreCompiled(compiledTemplate, data, context) {
		return "Process precompiled template and return final render.";
	},

	/**
	 * Extension of template files
	 */
	extension: ".jshtml",

	/**
	 * Tells that you implement preCompile and renderPreCompiled methods
	 */
	preCompilation: true
};

module.exports = TemplateAdapter;</code></pre>
				</article>

				<strong>templatePath</strong> is path to requested template. <strong>layoutPath</strong> is path
				to layout, can be null. <strong>data</strong> is object you call view from controller with.
				<strong>context</strong> is instance of controller for given request, you should want some extra data
				from controller (eg. current user's language).
			</section>

			<!-- Application -->
			<section>
				<h2 id="fold-api-application">Jumbo.Application<sub>namespace</sub></h2>
				<p>
					Namespace with core classes.
				</p>

				<!-- Locator -->
				<section>
					<h3 id="fold-api-application-locator">Locator<sub>class</sub></h3>

					<p>
						<strong>Locator</strong> is some kind of Router which is used to define valid
						<strong>locations</strong> - URLs.
					</p>

					<h4>Class synopsis</h4>
					<article class="code">
					<pre class="interface"><code class="javascript">class Locator {
	static get ParamTypes: RegExp
	static get instance: Locator

    <a href="#fold-api-application-locator-setHost">setHost(host)</a>;
    <a href="#fold-api-application-locator-setDelimiter">setDelimiter(delimiter)</a>;
    <a href="#fold-api-application-locator-setMainSubdomain">setMainSubdomain(subName)</a>;
    <a href="#fold-api-application-locator-addSubdomain">addSubdomain(subName)</a>;
    <a href="#fold-api-application-locator-addLocation">addLocation(locationName, location, [options = null, [subApp = null]])</a>;
    <a href="#fold-api-application-locator-addDefaultLocation">addDefaultLocation(location)</a>;
    <a href="#fold-api-application-locator-addUrlAlias">addUrlAlias(url, alias)</a>;
}</code></pre>
					</article>

					<section class="method">
						<h4 id="fold-api-application-locator-setHost">setHost(host)</h4>
						<p>
							Set server hostname - used for subapp link creation in rare cases when host not known from
							request
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>host : String</b></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-setDelimiter">setDelimiter(delimiter)</h4>
						<p>
							Set URL part delimiter spliting parts of url (controller, action etc.)
							eg. delimiter "~" => domain.tld/controller~action~id
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>delimiter : String</b> <em>String which will separate parts of URL</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-setMainSubdomain">setMainSubdomain(subName)</h4>
						<p>
							Set default subdomain which will route to base app; both urls with and without main
							subdomain
							will work. It's good for cases when you host application on some subdomain eg.
							myapp.domain.tld.
							Main subdomain is set to "www" in default.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>subName : String</b> <em>Subdomain name, eg. "www"</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-addSubdomain">addSubdomain(subName)</h4>
						<p>
							Register subapp to Locator as subdomain.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>subName : String</b> <em>Name of subapp</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-addLocation">
							addLocation(locationName, location[, options = null[, subApp = null]])
						</h4>
						<p>
							Add new location to Locator.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>locationName : String</b> <em>Name of location</em></li>
							<li><b>location : String</b> <em>Location string</em></li>
							<li><i>optional</i> <b>options : Object</b> <em>
								Location options which should define specific controller or action or can limit
								parameters
							</em></li>
							<li><i>optional</i> <b>subApp : String</b> <em>
								Name of subapp if you want to use this location only in given subapp
							</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-addDefaultLocation">
							addDefaultLocation(location)
						</h4>
						<p>
							Set default location of Locator.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>location : String</b> <em>Location string</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-locator-addUrlAlias">addUrlAlias(url, alias)</h4>
						<p>
							Create alias for some url. Eg. you have static file /public/robots.txt and you want this
							file
							under url /robots.txt so then add url alias addUrlAlias("/public/robots.txt",
							"/robots.txt").
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>url : String</b> <em>Target URL</em></li>
							<li><b>alias : String</b> <em>Alias for target URL</em></li>
						</ul>
					</section>
				</section>

				<!-- Request -->
				<section>
					<h3 id="fold-api-application-request">Request<sub>class</sub></h3>

					<p><strong>Request</strong> is wrap over Node.js's native request.</p>

					<h4>Class synopsis</h4>
					<article class="code">
					<pre class="interface"><code class="javascript">class Request {
    request: http.IncomingMessage;
    subApp: string;
    location: ILocation;
    controller: string; // Name of subapp
    controllerFullName: string;
    action: string; // Name of action
    actionFullName: string;
    params: { // URL params
        [key: string]: any;
    };
    body: {{fields: {}, files: {}}};
    noCache: boolean;
    sessionId: string;
    locale: string; // Requested locale
    beginTime: number; // Request begin time
    method: string; // Requested HTTP method

    <a href="#fold-api-application-request-isXhr">isXhr()</a>;
    <a href="#fold-api-application-request-getCookies">getCookies()</a>;
    <a href="#fold-api-application-request-getCookie">getCookie(name)</a>;
	<a href="#fold-api-application-request-getIP">getIP()</a>;
}</code></pre></article>

					<section class="method">
						<h4 id="fold-api-application-request-isXhr">
							isXhr()
						</h4>
						<h5>Returns</h5>
						<p>
							<b>Boolean</b> returns true if X-Requested-With == "XMLHttpRequest"
						</p>
					</section>

					<section class="method">
						<h4 id="fold-api-application-request-getCookies">
							getCookies()
						</h4>
						<h5>Returns</h5>
						<p>
							<b>Object</b> with cookies
						</p>
					</section>

					<section class="method">
						<h4 id="fold-api-application-request-getCookie">
							getCookie(name)
						</h4>
						<h5>Params</h5>
						<ul>
							<li><b>name : String</b> <em>Cookie name</em></li>
						</ul>
						<h5>Returns</h5>
						<p>
							<b>String</b> | <b>null</b> cookie's value
						</p>
					</section>

					<section class="method">
						<h4 id="fold-api-application-request-getIP">
							getIP()
						</h4>
						<h5>Returns</h5>
						<p>
							<b>String</b> Client's IP
						</p>
					</section>
				</section>

				<!-- Response -->
				<section>
					<h3 id="fold-api-application-response">Response<sub>class</sub></h3>

					<p><strong>Response</strong> is wrap over Node.js's native response.</p>

					<h4>Class synopsis</h4>
					<article class="code"><pre class="interface"><code class="javascript">class Response {
	response: http.ServerResponse;
	headers: {
		[headerProp: string]: any;
	};

	<a href="#fold-api-application-request-setCookie">setCookie(name, value[, expire[, domain[, path]]])</a>;
	<a href="#fold-api-application-request-unsetCookie">unsetCookie(name)</a>;
	<a href="#fold-api-application-request-redirectURL">redirectURL(url[, code])</a>;
}</code></pre></article>

					<section class="method">
						<h4 id="fold-api-application-request-setCookie">
							setCookie(name, value[, expire[, domain[, path]]])
						</h4>
						<h5>Params</h5>
						<ul>
							<li><b>name : String</b> <em>Cookie name</em></li>
							<li><b>value : String</b> <em>Cookie value</em></li>
							<li><i>optional</i> <b>expire : Number</b> <em>Expiration in seconds</em></li>
							<li><i>optional</i> <b>domain : String</b> <em>Domain</em></li>
							<li><i>optional</i> <b>path : String</b> <em>Path</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-request-unsetCookie">
							unsetCookie(name)
						</h4>
						<h5>Params</h5>
						<ul>
							<li><b>name : String</b> <em>Cookie name</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-application-request-redirectURL">
							redirectURL(url)
						</h4>
						<p>
							Redirect client to given URL.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>url : string</b></li>
						</ul>
					</section>
				</section>
			</section>

			<section>
				<h2 id="fold-base">Jumbo.Base<sub>namespace</sub></h2>

				<section>
					<h3 id="fold-base-controller">Controller<sub>class</sub></h3>

					<p><strong>Controller</strong> is base class which you should extend for creating controllers.
						<strong>Controller</strong> implements basic methods which you will need for processing actions.
					</p>

					<h4>Class synopsis</h4>
					<article class="code"><pre class="interface"><code class="javascript">class Controller {
	static clientMessagesId: string
	request: Jumbo.Application.<a href="#fold-api-application-request">Request</a>
	response: Jumbo.Application.<a href="#fold-api-application-response">Response</a>
	scope: Jumbo.Ioc.<a href="#fold-api-ioc-scope">Scope</a>
	session: { [key: string]: any; }
	crossRequestData: { [key: string]: any; }
	url: Jumbo.Utils.<a href="#fold-utils-url">Url</a>

	<a href="#fold-base-controller-addMessage">addMessage(message[, messageType])</a>;
	<a href="#fold-base-controller-exit">exit()</a>;
	<a href="#fold-base-controller-view">view([viewOrData[, data]])</a>;
	<a href="#fold-base-controller-renderView">renderView([viewOrData[, data]])</a>;
	<a href="#fold-base-controller-partialView">partialView([partialView[, data]])</a>;
	<a href="#fold-base-controller-template">template([view])</a>;
	<a href="#fold-base-controller-returnData">data(data[, type])</a>;
	<a href="#fold-base-controller-returnJSON">json(jsonObj)</a>;
	<a href="#fold-base-controller-returnError">error(message[, statusCode])</a>;
	<a href="#fold-base-controller-returnFileDownload">fileDownload(filePath[, newName[, contentType]])</a>;
	<a href="#fold-base-controller-redirect">redirect(url)</a>;
}</code></pre></article>

					<section class="method">
						<h4 id="fold-base-controller-exit">exit()</h4>
						<p>
							Completely ends basic workflow. Call it if you processed request/response on your own
						</p>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-view">view([viewOrData[, data]])</h4>
						<p>
							Ends request and return default or given view with given data. This action automatically
							handle double-sided rendering header and return required type (view, template, data, partial)
						</p>
						<h5>Params</h5>
						<ul>
							<li>
								<i>optional</i> <b>viewOrData : String | Object</b>
								<em>Name of specific view or just data if view is default (if match with action name)</em>
							</li>
							<li><i>optional</i> <b>data : Object</b> <em>Object with data for view</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-renderView">renderView([viewOrData[, data]])</h4>
						<p>
							Ends request and return rendered default or given view with given data.
						</p>
						<h5>Params</h5>
						<ul>
							<li>
								<i>optional</i> <b>viewOrData : String | Object</b>
								<em>Name of specific view or just data if view is default (if match with action name)</em>
							</li>
							<li><i>optional</i> <b>data : Object</b> <em>Object with data for view</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-partialView">partialView([partialView[, data]])</h4>
						<p>
							Ends request and return partial view without layout.
						</p>
						<h5>Params</h5>
						<ul>
							<li>
								<i>optional</i> <b>partialView : String | Object</b>
								<em>Name of spefic view or just data if view is default (if match with action name)</em>
							</li>
							<li><i>optional</i> <b>data : Object</b> <em>Object with data for view</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-template">template([view])</h4>
						<p>
							Return raw template corresponding to view.
						</p>
						<h5>Params</h5>
						<ul>
							<li>
								<i>optional</i> <b>view : String</b> <em>Name of spefic view</em>
							</li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-addMessage">addMessage(message[, messageType])</h4>
						<p>
							Add message to data for view, allow rendering messaes for clients.
							Messages are hold in cookie for next request or to time of first reading.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>message : String</b> <em>Your message for client</em></li>
							<li>
								<i>optional</i> <b>messageType : String</b>
								<em>Your custom type which you'll handle while rendering on your own</em>
							</li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-returnData">data(data[, type])</h4>
						<p>
							Ends request with result of given data and type
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>data : Object</b> <em>Data to be send</em></li>
							<li><i>optional</i> <b>type : String</b> <em>Mime type for gven data</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-returnJSON">json(jsonObj)</h4>
						<p>
							Accepts data in Object convert it to JSON and ends request with given data and
							application/json
							mime type
						</p>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-returnError">error(message[, statusCode = 500[, error]])</h4>
						<p>
							Ends request with error result. HTML file in /data/errors with given statusCode will be sent
							to client. If file not exists, plain text message "We're sorry but some error occurs." will be shown.
							Error object's details will be showed in browser in development mode.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>message : String</b> <em>Message which will be logged, it doesn't display to
								client</em>
							</li>
							<li><i>optional</i> <b>statusCode : Number</b> <i>default 500</i></li>
							<li><i>optional</i> <b>error : Error | Exception</b> Error object which details will be
								showed in browser in development mode</li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-returnFileDownload">fileDownload(filePath[, newName[, contentType]])</h4>
						<p>
							Sends file to client for download
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>filePath : String</b></li>
							<li><i>optional</i> <b>newName : String</b> <em></em></li>
							<li><i>optional</i> <b>contentType : String</b> <em></em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-base-controller-redirect">redirect(url)</h4>
						<p>
							Send response with location redirect.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>url : Url</b> Instance of Jumbo.Utils.Url which is in controller under <strong>this.url</strong> getter</li>
						</ul>
					</section>

				</section>
			</section>

			<!-- Ioc -->
			<section>
				<h2 id="fold-api-ioc">Jumbo.Ioc<sub>namespace</sub></h2>

				<section>
					<h3 id="fold-api-ioc-dicontainer">DIContainer<sub>class</sub></h3>

					<p><strong>DIContainer</strong> is IoC container which register and resolve your classes.</p>

					<h4>Class synopsis</h4>
					<article class="code"><pre class="interface"><code class="javascript">class DIContainer {
	static get LifetimeScope: Jumbo.Ioc.DIContainer.LifetimeScope;
	static get instance: Jumbo.Ioc.DIContainer

	<a href="#fold-api-ioc-dicontainer-register">register(expr, as)</a>;
	<a href="#fold-api-ioc-dicontainer-resolve">resolve(name)</a>;
	<a href="#fold-api-ioc-dicontainer-resolveUnregistered">resolveUnregistered(type)</a>;
}</code></pre></article>

					<section class="method">
						<h4 id="fold-api-ioc-dicontainer-register">register(expr, as)</h4>
						<p>
							Register Type to container under given name as service. If you place that name to
							constructor, it'll be matched with this type and injected to that parameter.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>expr : Function</b> <em>Class or arrow function returning class or some object</em></li>
							<li><b>as : String</b> <em>Registration name of service</em></li>
						</ul>
					</section>

					<section class="method">
						<h4 id="fold-api-ioc-dicontainer-resolve">resolve(name)</h4>
						<p>
							Resolve dependency which is registered under given name.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>name : String</b> <em>Registration name of Class</em></li>
						</ul>
						<h5>Returns</h5>
						<p>
							Return instance of registered type
						</p>
					</section>

					<section class="method">
						<h4 id="fold-api-ioc-dicontainer-resolveUnregistered">resolveUnregistered(type)</h4>
						<p>
							Create instance of given type and resolve it's dependencies.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>type : Function</b> <em>Type which you want to resolve</em></li>
						</ul>
						<h5>Returns</h5>
						<p>
							Return instance of given type with resolved dependencies
						</p>
					</section>
				</section>

				<section>
					<h3 id="fold-api-ioc-scope">Scope<sub>class</sub></h3>

					<p>
						<strong>Scope</strong> is IoC scope which resolve your types and returns same instances for
						already
						resolved types in this scope.
					</p>

					<h4>Class synopsis</h4>
					<article class="code"><pre class="interface"><code class="javascript">class Scope {
	<a href="#fold-api-ioc-scope-resolve">resolve(name)</a>;
	<a href="#fold-api-ioc-scope-resolveUnregistered">resolveUnregistered(type)</a>;
}</code></pre></article>

					<section class="method">
						<h4 id="fold-api-ioc-scope-resolve">resolve(name)</h4>
						<p>
							Resolve dependency which is registered under given name.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>name : String</b> <em>Registration name of Class</em></li>
						</ul>
						<h5>Returns</h5>
						<p>
							Return instance of registered type
						</p>
					</section>

					<section class="method">
						<h4 id="fold-api-ioc-scope-resolveUnregistered">resolveUnregistered(type)</h4>
						<p>
							Create instance of given type and resolve it's dependencies.
						</p>
						<h5>Params</h5>
						<ul>
							<li><b>type : Function</b> <em>Type which you want to resolve</em></li>
						</ul>
						<h5>Returns</h5>
						<p>
							Return instance of given type with resolved dependencies
						</p>
					</section>
				</section>
			</section>

			<!-- Logging -->
			<section>
				<h2 id="fold-logging">Jumbo.Logging<sub>namespace</sub></h2>
				<p>
					<strong>JumboJS</strong> contain fully configurable logging with log levels. Messages are logged to
					files, each LogType has own file.
				</p>

				<h3>Log<sub>class</sub></h3>
				<p>
					Log is static class which give you ability log your messages. It accessible from
					global variable via <span class="inline-code">Jumbo.Logging.Log</span>.
				</p>

				<h4>Class synopsis</h4>
				<article class="code"><pre class="interface"><code>class Log {
	static get <a href="#fold-log-logTypes">LogTypes()</a>;
	static get <a href="#fold-log-logLevels">LogLevels()</a>;
	static level: { Error, Warning, Normal, Talkative }
	static <a href="#fold-log-error">error(message[, type[, level]])</a>;
	static <a href="#fold-log-warning">warning(message[, type[, level]])</a>;
	static <a href="#fold-log-line">line(message[, type[, level]])</a>;
}</code></pre></article>

				<section class="method">
					<h4 id="fold-log-logTypes">get LogTypes()</h4>
					<h5>Returns</h5>
					<p>
						<span class="inline-code">{ Http, Std }</span>
						<em>enum of available LogTypes</em>
					</p>
				</section>

				<section class="method">
					<h4 id="fold-log-logLevels">get LogLevels()</h4>
					<h5>Returns</h5>
					<p>
						<span class="inline-code">{ Error, Warning, Normal, Talkative }</span>
						<em>enum of available LogLevels</em>
					</p>
				</section>

				<section class="method">
					<h4 id="fold-log-error">error(message[, type[, level]])</h4>
					<h5>Params</h5>
					<ul>
						<li><b>message : String</b> <em>Message to log</em></li>
						<li><i>optional</i> <b>type : Jumbo.Logging.Log.LogTypes</b> <em>Log type</em></li>
						<li><i>optional</i> <b>level : Jumbo.Logging.Log.LogLevels</b> <em>Log level</em></li>
					</ul>
				</section>

				<section class="method">
					<h4 id="fold-log-warning">warning(message[, type[, level]])</h4>
					<h5>Params</h5>
					<ul>
						<li><b>message: String</b> <em>Message to log</em></li>
						<li><i>optional</i> <b>type</b> <em>Log type</em></li>
						<li><i>optional</i> <b>level</b> <em>Log level</em></li>
					</ul>
				</section>

				<section class="method">
					<h4 id="fold-log-line">line(message[, type[, level]])</h4>
					<h5>Params</h5>
					<ul>
						<li><b>message</b> <em>Message to log</em></li>
						<li><i>optional</i> <b>type</b> <em>Log type</em></li>
						<li><i>optional</i> <b>level</b> <em>Log level</em></li>
					</ul>
				</section>
			</section>

			<!-- Validation -->
			<!--<section>-->
				<!--<h2 id="fold-validation">Jumbo.Validation<sub>namespace</sub></h2>-->

				<!--<h3>Validator<sub>class</sub></h3>-->

				<!--<h3>PropertyValidator<sub>class</sub></h3>-->

			<!--</section>-->

			<!-- Utils -->
			<section>
			<h2 id="fold-utils">Jumbo.Utils<sub>namespace</sub></h2>

			<h3>Url<sub>class</sub></h3>
				<p>
					Url is class which helps you create URLs. It copy locale, protocol, host and controller
					from given request.
				</p>

				<h4>Class synopsis</h4>
				<article class="code"><pre class="interface"><code>class Url {
	<a href="#fold-utils-url-constructor">constructor(request)</a>;
    <a href="#fold-utils-url-action">action(action[, controller[, params]])</a>;
    <a href="#fold-utils-url-controller">controller(controller)</a>;
    <a href="#fold-utils-url-subApp">subApp(subApp)</a>;
    <a href="#fold-utils-url-params">params(params)</a>;
    <a href="#fold-utils-url-locale">locale(locale)</a>;
    <a href="#fold-utils-url-location">location(location)</a>;
    <a href="#fold-utils-url-getUrl">getUrl()</a>;
}</code></pre></article>

				<section class="method">
					<h4 id="fold-utils-url-constructor">constructor(request)</h4>
					<h5>Params</h5>
					<ul>
						<li><b>request: Jumbo.Application.Request</b></li>
					</ul>
				</section>

				<section class="method">
					<h4 id="fold-utils-url-action">action(action[, controller[, params]])</h4>
					<h5>Params</h5>
					<ul>
						<li><b>action: string</b></li>
						<li><i>optional</i> <b>controller: string</b></li>
						<li><i>optional</i> <b>params: Object</b></li>
					</ul>
					<h5>Returns</h5>
					<p>
						<b>Url</b> instance of itself
					</p>
				</section>
			</section>
		</section>

		<!-- PACKAGES -->
		<section>
			<h1 id="fold-packages">Packages</h1>

			<!-- Jumplate -->
			<section>
				<h2 id="fold-jumplate">Jumplate</h2>
				<p>
					<strong>Jumplate</strong> is <strong>JumboJS</strong>'s default template engine.
				</p>
				<p>
					It's one of the fastest (faster than Jade, EJS, Handlebars.js, Underscore) Node.js template
					engine with cacheable precompilation. Jumplate is able to compile 16 000 templates in one second
					and render 400 000 precompiled templates in one second in one 2,33&nbsp;Ghz core.
				</p>
				<p>
					Template code is compiled to native JavaScript (can be cached), then it can be rendered with given
					set of data into final HTML.
				</p>


				<h3>Variables</h3>
				All variables begin with <strong>$</strong> symbol.
				Each variable can be printed as <span class="inline-code">{{$variable}}</span>.
				Output has escaped html entities (<, >, &, ", ').
				If you want to print variable without escaping use <span class="inline-code">{{!$variable}}</span>.

				It's possible to define variable right inside
				template with <span class="inline-code">{{var $x = new Date().toString()}}</span>


				<h3>Comments</h3>
				<p>
					Jumplate has block coment which looks like this
					<span class="inline-code">{{* Command brackets with asterisks *}}</span>
				</p>


				<h3>Block</h3>
				Define block of code which <b>is rendered</b> in place of definition.
				Can be reused with <span class="inline-code">{{include blockName}}</span>.
				Block can be included many times.
				<span class="inline-code br">{{block blockName}}Block content{{/block}}</span>


				<h3>Define</h3>
				Define is similar to block, but define will <b>not be rendered</b> in place of definition.

				<span class="inline-code br">
					{{define defineBlockName}}Define block content will be rendered here{{/define}}</span>


				<h3>Defined</h3>
				Existence of block and definition can be verified with
				<span class="inline-code">{{defined defineBlockName}}{{/defined}}</span>.


				<h3>Include</h3>
				Include block, define or other template file.

				<span class="inline-code">{{include blockName}}</span> will include block with given name.

				<span class="inline-code">{{include "./path/to/template.tpl"}}</span> will include file with given path.
				Double quotes required.

				<h3>Cycles</h3>
				<p>
					There are two cycles.
					<span class="inline-code br">{{for $x = 0; $x < $count; $x++}} For content {{/for}}</span>
					and
					<span class="inline-code br">{{for $item of $list}} Foreach content {{/for}}</span>
				</p>

				<blockquote>
					In case of for..of there is special variable `$itemKey` which is accessible
					inside cycle block and contains key of current item.
				</blockquote>

				<p>
					In both cycles you can use commands
					<span class="inline-code br">
					{{first}}Will be rendered if this iteration is first{{/first}}
				</span>
					<span class="inline-code br">
					{{last}}Will be rendered if this iteration is last{{/last}}
				</span>
					<span class="inline-code br">
					{{even}}Will be rendered if this iteration is even{{/even}}
				</span>
					<span class="inline-code br">
					{{odd}}Will be rendered if this iteration is odd{{/odd}}
				</span>
				</p>


				<h3>Conditions</h3>
				<article class="code">
			<pre><code class="html">{{if $x == "condition"}}
	if condition true...
{{elseif $x == "else if conditio"}}
	if else if condition true...
{{else}}
	else...
{{/if}}</code></pre>
				</article>

				<h3>Localization</h3>
				<p>
					You can register localization hadler to Jumplate and
					then use command <span class="inline-code">{{loc key.for.requested.translation}}</span>
					which will call your handler with given key as parameter.
				</p>

				<article class="code">
					<pre><code class="javascript">Jumplate.registerLocalizator(function (key, locale) {
	return SOME_EXAMPLE_MAP[locale][key];
});</code></pre>
				</article>

				<section>
					<h3>Helpers</h3>
					<p>
						You can define own helpers, inline and block too. On class Jumplate
						there are static methods
						<span class="inline-code br">Jumplate.registerHelper(name, helper: (...argumets) => string)</span>
						and
						<span class="inline-code br">Jumplate.registerBlockHelper(name, helper: (blockContent: string, ...arguments) => string)</span>
					</p>

					<article class="code">
					<pre><code class="javascript">Jumplate.registerHelper("link", function(text, url) {
	return `&lt;a href="${url}">${text}&lt;/a>`;
});</code></pre>
					</article>

					<p>Then you can use it in template like this.</p>

					<article class="code">
					<pre><code class="html">{{block menu}}
	{{for $item of $menuItems}}
		{{link($item.text, $item.url)}}
	{{/for}}
{{/block}}</code></pre>
					</article>
				</section>

				<section>
					<h3>Predefined helpers</h3>

					<p>In default Jumplate template adapter there are some predefined helpers which should help you with
						some stuffs. There will be more helpers soon.</p>

					<!-- FORM -->
					<section>
						<h4>Form</h4>
						<p>
							Helper <strong>form</strong> is block helper which create &lt;form> and &lt;/form> around
							your code. The begining tag will look like
							<span class="inline-code br">&lt;form method="POST" action="#" enctype="multipart/form-data"></span>
						</p>

						<article class="code">
						<pre><code class="html">{{block content}}
	&lt;h1>Registration&lt;/h1>
	{{form}}
		&lt;input type="text" name="email">
		&lt;input type="password" name="pass">
		&lt;input type="submit" name="send" value="Sign Up">
	{{/form}}
{/block}</code></pre>
						</article>
					</section>

					<!-- LINK -->
					<section>
						<h4>Link</h4>
						<p>
							Helper <strong>link</strong> is inline helper which create url.
							<span class="inline-code br">link(action[, controller[, params[, locale]]]</span>
						</p>

						<article class="code">
						<pre><code class="html">{{block menu}}
	{{for $item of $menuItems}}
		{{* Will create eg. /page/nodejs -> PageController.actionNodejs() *}}
		&lt;a href='{{link($item.section, "Page")}}'>{{$item.text}}&lt;/a>
	{{/for}}
{{/block}}</code></pre>
						</article>
					</section>

					<!-- LOCATION LINK -->
					<section>
						<h4>Location Link</h4>
						<p>
							Helper <strong>locationLink</strong> is inline helper which create location url.
							<span class="inline-code br">locationLink(location, action[, controller[, params[, locale]]]</span>
						</p>

						<article class="code">
						<pre><code class="html">{{block menu}}
	{{for $item of $menuItems}}
		{{* Will create eg. /page/nodejs -> PageController.actionNodejs() by location registered as "default" *}}
		&lt;a href='{{link("default", $item.section, "Page")}}'>{{$item.text}}&lt;/a>
	{{/for}}
{{/block}}</code></pre>
						</article>
					</section>

					<!-- APPLINK -->
					<section>
						<h4>Applink</h4>
						<p>
							Helper <strong>applink</strong> is inline helper which create subapp url in same way as
							helper link. But here is new parameter at the begining which take sub-app name.
							<span class="inline-code br">locationLink(subapp, action[, controller[, params[, locale]]]</span>
						</p>

						<article class="code">
						<pre><code class="html">{{block adminMenu}}
	{{* Will create eg. admin.domain.tld/page/new -> PageController.actionNew() in admin subapp *}}
	&lt;a href='{{applink("admin", "new", "Page")}}'>Create new page&lt;/a>
	&lt;a href='{{applink("admin", "list", "User")}}'>List all users&lt;/a>
{{/block}}</code></pre>
						</article>
					</section>
				</section>
			</section>

			<!--<section>-->
			<!--<h2 id="fold-jumbo-unimapperjs">UniMapperJS</h2>-->
			<!--<p>-->
			<!--...-->
			<!--</p>-->
			<!--</section>-->
		</section>
	</main>
</body>
</html>